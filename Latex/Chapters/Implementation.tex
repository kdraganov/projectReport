\chapter{Implementation}
This chapter aims to present the reader with explanation of the key implementation aspects. These include major challenges, decisions and problems that have been encountered and taken during the course of this project. I have tried to avoid going into too much technical details except where this is essential and provides the reader with better insight and understanding of the material.

\section{iBus AVL Data}
The data that is used for this project is provided by the Technical Service Group (TSG) at TFL. The data consists of comma separated value files. There is an individual file for every different bus operator which contains the data for all buses currently operated by this company. Initially every bus in the network would transmit its unique identification number and GPS coordinates approximately every 30 seconds \cite{Hounsell201276}. This information is then preprocessed by a central server. This results in more information being derived as the central server has knowledge of the whole network and the bus schedules and headways. This results in the CSV feed files that have been provided to us for this project. An example of the content of the raw feed file and a formatted version is presented in section A.4 of Appendix A. Below I have provided a detailed explanation of each field in these files.
\begin{itemize}
	\item \textbf{Vehicle Id} - this is a unique id of the vehicle.
	\item \textbf{Bonnet Code} - this is the bonnet code of the bus.
	\item \textbf{Registration Number} - this is the number of the registration plate of the bus. 
	\item \textbf{Time of Data} -  this refers to the date and time of when this data is received from the respective vehicle.
	\item \textbf{Base Version} - this the version of the system that is run by the respective bus.
	\item \textbf{Block Number} - this is the block number on which the vehicle is running
	\footnote{\label{loggedProperly}This is only valid when bus is properly logged.}$^{,}$\footnote{\label{routeVariant}Not available in route variant.}.
	\item \textbf{Trip Id} - stores the internal trips id\footnotemark[\ref{loggedProperly}]$^{,}$\footnotemark[\ref{routeVariant}].
	\item \textbf{LBSL\footnote{London bus services limited \cite{lbsl}} Trip Number} - this is LBSL trip number\footnotemark[\ref{loggedProperly}].
	\item \textbf{Trip Type} - the type of the trip\footnote{1:From depot to start stop of the block; 2:To new starting point;  3:Normal trip with passengers; 4:From the last stop of the block to the depot; 5:Without passengers; 6:Route variant; 7:Vehicle not logged in either block or route}.
	\item \textbf{Contract Route} - the route name\footnotemark[\ref{loggedProperly}]$^{,}$\footnotemark[\ref{routeVariant}].
	\item \textbf{Last Stop ShortDesc} - this is the lbsl code of the last stop visited by the respective bus\footnotemark[\ref{loggedProperly}]$^{,}$\footnotemark[\ref{routeVariant}].
	\item \textbf{Schedule Deviation} - this is the standard deviation from the schedule, calculated using the bus position telegram, for the respective bus\footnotemark[\ref{loggedProperly}]$^{,}$\footnotemark[\ref{routeVariant}].
	\item \textbf{Longitude} - this is longitude of the place from where the vehicle is sending the telegram\footnote{\label{gps}GPS raw data divided by 3,600,000.}.
	\item \textbf{Latitude} - this is latitude of the place from where the vehicle is sending the telegram\footnotemark[\ref{gps}].
	\item \textbf{Event Id} - the last event Id.
	\item \textbf{Duration} - currently not being populated.
\end{itemize}

The information we are interested is the deviation from the schedule. This value is calculated the same way for both low\footnote{Less than 5 buses per hour.} and high\footnote{5 or more buses per hour.} frequency buses by knowing the bus schedule. It must be noted that it is possible vehicles would start the route already with some deviation from the schedule.

%Include a sample of the data and explanation of all fields
%Explain what the schedule deviation value means
%Include discussion on how the network is represented and the source of the file - TFL open data
%iBus system generate very short telegram messages with the bus location \cite{Hounsell201276}. This information is then processed on a server and more information is calculated and derived.
%The data that has been provided by Technical Service Group (TSG) at TFL for this project consists of preprocessed iBus feeds. This feeds currently are being generated every 5 minutes. Each file consists of the following fields:
%The information we are interested is the deviation from the schedule. This is calculated by knowing the expected arrival time of the bus at a stop from the schedule and is compared to the observed time. This value is calculated the same way for both low and high frequency buses(Low frequency buses are supposed to run according to a fixed schedule (e.g. a bus should arrive at stop at predefined time) and usually routes which have less than 5 buses an hour. High frequency bus routes should maintain headways - this meaning a bus should be arriving at stop at predefined intervals (e.g. each 2 minutes)). More about the supplied data for this project would be covered in the requirements section.
%Key property of time series data is stationarity. This means that the behaviour of the time series data does not change over time. In our case the data generally speaking the time series data is not stationary. However if we consider short window size it might be possible to treat the data as close to stationary.

\section{Prototypical Tool}
The system we have developed as a prototype which to satisfy our aims consists of two sub systems. These are the disruption engine which address the first aim of detecting disruptions in the bus network and a web front end application which to visualise the calculated disruptions. Below I have presented the major implementation decisions and challenges that were faced during the development of this system.

\subsection{Disruption Engine}

Why have I have decided to use database vs flat file data store. Pros and cons
Why postgresql. Reference to the database model
Explanation and discussion of the database model.

%However as other research has pointed out \cite{1251929} calculating travel time as measure for congestion is difficult task and it is very dependable on the environment and its conditions (e.g. weather, time of day, public demand etc.). For this reason and because of the data available this project would not try to measure disruptions by calculating travel time or bus speeds.TFL has provided us with example of the AVL data which among other things contains a the GPS coordinates of the bus at a given point in time and preprocessed deviation from the schedule value. For the rest of this chapter we assume this value is accurately calculated and that we would receive this value for each bus in the network at some regular interval. The provided data is discussed in further details in Chapter 5.
%For this project we monitor and measure the schedule deviation value as calculating the congestion is very challenging and still not very well understood in the case of arterial urban traffic.
%However from the literature \cite{1251929} we can see that it could be difficult to precisely define what we mean by congestion in a transport network. It seems that congestion could mean various things to different studies and people.
What is the general approach I have taken
%WHAT ARE THE CHALLENGES AND HOW WERE THEY OVERCOMED
	\subsubsection{Technologies}
	The tool 
	SCALA, XML database connection file, Database is Postregsql
	Why Scala and DB Postgresql.
	\subsubsection{Bus Network representation}
	What other data is needed?
	\subsubsection{Monitoring for new feeds}
	
	\subsubsection{Feed File Processing and observation extraction}
	How is the input processed etc. ...
	
	Graphics to depict how the algorithm works
	\subsubsection{Calculating Delay}
	The important factors to consider are the weights and the period/window size to use. We could also apply exponential smoothing on top of the WMA.
	Problems:
The bus could have started the journey ahead of schedule and thus to intentionally be losing time.
The buses could curtail anywhere on a route without notification
The buses could be diverted (this could be short term or long term) it can also be for few stops or it could be a longer diversion.

	\subsubsection{Detecting disruptions}
	
\subsection{Graphical User Interface}
The engine implementation describe above address only half of our requirements. In order to fully meet the project goals we need to be able to visualise the detected disruption in the network. For this reason I have decided to implement the visualisation part of the system as a separate web application. The advantages of this approach is that this provides universal access to the information. We only need to deploy this application ones and it can be accessed from multiple clients running different operating systems and even devices. I have decide to use Ruby running on Rails framework. The reason for this is its recent popularity and wide support in terms of third party libraries and community information and guides.

The Rails framework [REFERENCE] is full stack open source web framework implemented in Ruby. It is relatively easy to use and maintain and it support a wide range of software engineering paradigms and patterns. The main ones being Model View Controller (MVC), Don't Repeat Yourself (DRY), Convention Over Configuration (CoC) and the Active Record pattern \cite{fowler2003patterns}. I have also made use of Foundation Cascading Style Sheets (CSS) front-end framework. This framework has enabled quick prototyping as it has a rich library of predefined components. However its main advantage over some other similar frameworks is its notion of grid which allows for quick and easy implementation of responsive websites. Making the web application with responsive design allows us to reach more platforms and client systems with a single application. This allows us with little additional implementation effort and time to achieve results which look good on both large screens (desktop computers, laptops etc.) as well as small mobile devices (e.g. smart phones, tablets etc.). This framework also has the advantages of good support in terms of documentation and add-ons and it is lightweight. Sample of what the system user interface looks like can be seen in appendix A [REFERENCE TO APPENDIX].

The ruby on rails web application is implemented following the MVC pattern. In our case it consists of few simple models representing the corresponding database tables, controllers and a number of views (some of which are partials). The models are implemented as Active Records which provide interfaces to the respective database tables. They provide create, read, update and delete (CRUD) functionalities. The controllers are responsible for processing the client request by parsing and checking for any parameters, credentials where necessary and responding with the requested information. The responses are in most cases rendered views containing the requested information.

One important aspect of the user interface is how to update the disruption list in real time whenever there are changes. This is achieved by implementing Ajax short polling. This means that we use asynchronous JavaScript on the client side to make request to the server at predefined intervals. Alternative methods for implementing the updating of the list include Web Sockets, Ajax Long Polling, Server Sent Events (SSE). The main advantages of using Ajax short polling over Web Sockets and SSE are that Ajax Short Polling is supported by all major web browsers unlike SSE which lack Internet Explorer support and it is easy and quick to implement it. The drawback of using Ajax polling is that in order to achieve near real time update the clients will need to make frequent request to the server which wastes network and server resources. SSE is probably the best approach in this scenario as it establishes a persistent long-term connection on which the server is able to push new data once it becomes available to all connected clients. However SSE are not supported by Internet Explorer which is one of the main web browsers CentreComm staff use and also SSE require a concurrency enabled server. Web Sockets provide a persistent two way connection between the client and the server however in our case we are mainly interested in pushing new data from the server to the client. There is very little information the clients need to send to the server and thus we have excluded this approach as viable one.

The disruptions at any point in time are visualised in tabular form. This provides instant awareness of what the network state is to the CentreComm operators. Disruptions are prioritised by their severity and are color coded. Further details for disruption are displayed on request of the user. This includes a graph representation of the delay observed on each section along the disrupted route. On this graph the cumulative delay for this route is also visible. When hovered the graph displays details for this section including the start and end stop of it and the number of observations.

\subsection{Problems \& Optimisations}
PROBLEM - some buses might skip transmitting data even if they are properly logged on
Data available, data frequency, no knowledge when buses do curtail, not taking into account bus dwell time, bus drivers who are running ahead of schedule could be driving slower on purpose and thus. Tool gives an upper bound of the of the WMA lost time per section. 
