\chapter{Testing}
Testing is important and integral part of any software development project. It is necessary to carry out testing throughout the implementation as well as once the system is completed in order to make sure it functions correctly according to the requirements and the design.
%The disruption engine consists of a number of individual components and algorithms.These are tested using a number of unit tests. Due to the nature of the engine, stress tests were carried out to test it for any memory leaks and performance issues. Evaluation of the output of the disruption engine will be performed by first carrying out further literature review to find some guidance on what window for the data to consider to use and what weights to use for optimal results. This will be followed by running the system on a given set of data (e.g. a week worth of AVL data) and comparing the output with the actual state of the network during this period.

%The user interface consists of a simple web application capable of displaying list of disruptions. Testing and evaluation of this web application will be performed as user testing. As I mentioned above, some feedback and problems were identified which will be addressed and fixed. Follow up user tests will be carried out by giving access to friends and family to the web site to use and give feedback on. This should give reasonable confidence in the correctness of the user interface as there is no complex logic incorporated in the web front end application.
\section{Unit Testing} 
As described in the previous chapters the system is composed of a number of classes each of them representing different part of the bus network with its own functionalities and responsibilities. Thought the development of the product a number of unit test have been carried out in order to ensure that each of the classes function correctly as per requirements and carries out the required task. Each module was tested separately before being connected to the rest of the system.

\section{White Box Testing}
Apart from the unit testing through the development of the tool we have made use of the debugging tool provided by IntelliJ IDEA integrated development environment (IDE) \footnote{https://www.jetbrains.com/idea/}. This was the main IDE used for the development of this project and has provided many useful tools and support. The built-in debugger allowed us to carry out inspection of the code during its execution. This means that we could halt the execution (in real-time) at specific point during the calculations and examine the state of the program (the values of all variables).

\section{Functional Testing}
The proposed prototype system in this project consisted of an engine responsible for calculating the disruption and a separate front end responsible for visualising the output from the engine. Because of this separation most of the functional testing was performed on the front end web application. This was carried out by manually testing the functionality of the web application and verifying that it resulted in the correct output. The user interface has been tested by me throughout development, some feedback has been received on it during demonstration and discussions with CentreComm and my supervisor. In addition to that I have asked family and friends to spend time and test the functionality of the user interface for this I provided them with a list of use cases and the expected behaviour. This has proved useful in identifying some issues with the functionality and the compatibility of the product with different web browsers and systems. All of the identified problems have been addressed and rectified after that.

\section{Stress Testing}
On of the main requirements for detecting the disruptions in the bus network is for this to be calculated in real-time. Because of this we need to make sure that the implementation is able to cope with large amounts of data quickly. Also as the system will run continuously with more data being made available for the system throughout its execution it need to be ensured that any memory that is occupied by data that is irrelevant (old) be discarded appropriately without creating any memory leaks. 

The approach that I have taken in order to test the system for such performance issue consisted of firstly creating an automated script for simulating the feed pushing to the tool. This program takes two main input parameters. One is the directory in which the feeds for the simulation are being stored and the second main input is the rate at which these files are copied to the directory which is used by the disruption engine for monitoring. Currently as discussed previously in this report the AVL data files which were provided for this project are generated every 5 minutes. However this could be changed if the tool goes into production. For this reason we need to make sure that the proposed prototype is capable of dealing with large sets of data being pushed every 30 seconds (as this is the current rate iBus equipped buses transmit data). Apart from the rate at which new data is pushed to the tool the performance of our system depends mainly on how much data is pushed (e.g. during the night ours there are less active buses thus less data generated compared to daytime) and also on how many disruptions are detected in the system. The earlier is clearly obviously that if there is more data to be processed the system would naturally take longer. However the second statement is because we only update the database information for a route, run and section only if there is changes. This means that the update time could vary greatly depending on the number of changes at each network update. In order to minimise the impact of this the system is implemented in such a way that it makes all database updates after a network update in one transaction. This means that the main performance bottleneck of the system becomes the updating of the database. The initial versions of the prototype did not make use of a database, but rather wrote the output into flat CSV files. The reason for adding a database in place of the flat files is that the implementation change, so that it could keep historical state of the network which could later be used for further analysis and reports which are features that have received a lot of positive feedback from TFL.

Simulations have been run to make sure the system is capable of processing and updating itself in real-time. This tests have been carried out on a laptop running Intel Core i7-3610QM with 16GB DDR3 1600Mhz of ram and Windows 10 x64 bit operating system. The simulations consisted of feeding the tool with a week worth of data that was provided by TFL. The data was made of 21629 separate (each one for a single bus operator) AVL feeds which have been group into 2814 batches according to their timestamps. The total size of the sample is 1.07 Gigabyte (1076394754 bytes) and the average size of a single feed file is 49.77 Kilobytes (49766.27 bytes). We ran a number of simulations with this data keeping all parameters the same and re-initialising the system before each run. The only parameter we altered, to make sure the system is capable of handling data at higher rates, is the rate at which the feed simulation program pushed the AVL files. The results could be seen on figure A.10 in Appendix A. From the results we can conclude that even on a normal computer in a development environment the system is capable of producing output in almost real-time. The memory usage also could be seen in the results shown on figure A.10 in Appendix A. The memory was measured through the execution of the tool and readings were taken every minute. The memory usage is highly dependent on the amount of the data being processed and also depends on when the Java Virtual Machine(JVM\footnote{http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html}) garbage collector executes. The latter is because the system might have already removed all references to some object, however this memory would not be unallocated until the JVM garbage collector is called.

The system current implementation is updating each route in the network consecutively. However the system has been implemented with concurrent execution of this calculation in mind. This means that it could easily be updated such that each route is concurrently processed. This is also the case for the parsing of the CSV feed files and observation extraction. As the aim of this project is to built a prototype I have decided not to spend the limited project time on such optimisations as it is more important to prove if this is viable solution. As it can be seen from the stress tests carried out even without such parallelism in place the system produces results in reasonable amount of time.

%The results shows us that there are not problems with dealing with large amount of information in real time even on a normal mobile computer. It can also be seen that memory usage is within the capabilities of typical modern computer. We can see big variations in the memory usage, however this is normal as we do not explicitly allocate and deallocate memory. Scala runs on the Java Virtual Machine (JVM) which has garbage collector reponsible for freeing up unused memory. The only thing the programmer need to make sure for is that any objects that are unused should have no references pointing to them, then when JVM garbage collector executes it will return (free up) all unused memory. This means that our system memory usage depends on:
%\begin{itemize}
%	\item How fast new data is pushed.
%	\item How much data is being used (as discussed in the previous chapter).
%	\item How often the garbage collector executes.
%\end{itemize}